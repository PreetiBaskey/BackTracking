class Solution {
public:
    int n;
    int minScore = INT_MAX;
    vector<int> result;
    void backtrack(vector<int> &nums, vector<int> &visited, vector<int> &perm, int currScore) {
        if(currScore >= minScore) {
            return;
        }
        if(perm.size() == n) {
            int lastPermEle = perm.back();
            int firstPermEle = nums[perm[0]]; // doing cylic - from last to first element
            currScore += abs(lastPermEle - firstPermEle);
            if(minScore > currScore) {
                minScore = currScore;
                result = perm;
            }
            return;
        }

        for(int i = 0; i < n; i++) {
            if(!visited[i]) {
                //do
                visited[i] = 1;
                perm.push_back(i);

                //explore
                int m = perm.size();
                int diff = abs(perm[m - 2] - nums[perm[m - 1]]);
                backtrack(nums, visited, perm, currScore + diff);

                //undo
                visited[i] = 0;
                perm.pop_back();
            }
        }
    }
    vector<int> findPermutation(vector<int>& nums) {
        n = nums.size();
        vector<int> visited(n, 0);
        vector<int> perm;
        int currScore = 0;

        perm.push_back(0);
        visited[0] = 1;
        backtrack(nums, visited, perm, currScore);

        return result;
    }
};
