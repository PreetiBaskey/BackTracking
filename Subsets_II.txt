class Solution {
public:
    // Helper function for recursive backtracking with duplicate handling
    void backtrack(vector<int> &nums, vector<vector<int>> &result, vector<int> &curr, int idx) {
        result.push_back(curr); // Add the current subset

        for(int i = idx; i < nums.size(); i++) {
            if(i > idx && nums[i - 1] == nums[i]) {
                continue;
            }

            //do
            curr.push_back(nums[i]);

            //explore
            // Recurse with the next index
            backtrack(nums, result, curr, i + 1);

            //undo
            curr.pop_back();
        }
    }
//To correctly handle duplicates, you need to modify the logic in two main ways:
//1.Sort the input array: This groups duplicate numbers together.
//2.Add a skip condition: Within the backtracking function, after including an element and exploring that branch, you need logic to "skip" identical adjacent elements in the next iteration to avoid generating redundant branches.

    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end()); // STEP 1: Sort the array
        vector<vector<int>> result;
        vector<int> curr;
        int idx = 0;
        
        backtrack(nums, result, curr, idx);

        return result;
    }
};
